// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package repository

import (
	"context"
	"time"
)

const addSession = `-- name: AddSession :one
INSERT INTO "user_sessions" ("userId", "tokenHash", "userAgent", "ipAdress", "expiresAt")
VALUES ($1, $2, $3, $4, $5) RETURNING id, "userId", "tokenHash", "userAgent", "ipAdress", "expiresAt", "createdAt"
`

type AddSessionParams struct {
	UserId    int32     `json:"userId"`
	TokenHash string    `json:"tokenHash"`
	UserAgent string    `json:"userAgent"`
	IpAdress  string    `json:"ipAdress"`
	ExpiresAt time.Time `json:"expiresAt"`
}

func (q *Queries) AddSession(ctx context.Context, arg AddSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, addSession,
		arg.UserId,
		arg.TokenHash,
		arg.UserAgent,
		arg.IpAdress,
		arg.ExpiresAt,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserId,
		&i.TokenHash,
		&i.UserAgent,
		&i.IpAdress,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const clearUserSessions = `-- name: ClearUserSessions :exec
DELETE FROM "user_sessions" WHERE "userId" = $1
`

func (q *Queries) ClearUserSessions(ctx context.Context, userid int32) error {
	_, err := q.db.Exec(ctx, clearUserSessions, userid)
	return err
}

const deleteSessionByHash = `-- name: DeleteSessionByHash :exec
DELETE FROM "user_sessions" WHERE "tokenHash" = $1
`

func (q *Queries) DeleteSessionByHash(ctx context.Context, tokenhash string) error {
	_, err := q.db.Exec(ctx, deleteSessionByHash, tokenhash)
	return err
}

const deleteSessionById = `-- name: DeleteSessionById :exec
DELETE FROM "user_sessions" WHERE "userId" = $1 AND "id" = $2
`

type DeleteSessionByIdParams struct {
	UserId int32 `json:"userId"`
	ID     int32 `json:"id"`
}

func (q *Queries) DeleteSessionById(ctx context.Context, arg DeleteSessionByIdParams) error {
	_, err := q.db.Exec(ctx, deleteSessionById, arg.UserId, arg.ID)
	return err
}

const getSessionFromHash = `-- name: GetSessionFromHash :one
SELECT id, "userId", "tokenHash", "userAgent", "ipAdress", "expiresAt", "createdAt" FROM "user_sessions" WHERE "tokenHash" = $1
`

func (q *Queries) GetSessionFromHash(ctx context.Context, tokenhash string) (UserSession, error) {
	row := q.db.QueryRow(ctx, getSessionFromHash, tokenhash)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserId,
		&i.TokenHash,
		&i.UserAgent,
		&i.IpAdress,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
SELECT id, "userId", "tokenHash", "userAgent", "ipAdress", "expiresAt", "createdAt" FROM "user_sessions" WHERE "userId" = $1 ORDER BY "id" ASC
`

func (q *Queries) GetUserSessions(ctx context.Context, userid int32) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessions, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserId,
			&i.TokenHash,
			&i.UserAgent,
			&i.IpAdress,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSession = `-- name: UpdateSession :exec
UPDATE "user_sessions" SET "tokenHash" = $2, "expiresAt" = $3 WHERE "userId" = $1
`

type UpdateSessionParams struct {
	UserId    int32     `json:"userId"`
	TokenHash string    `json:"tokenHash"`
	ExpiresAt time.Time `json:"expiresAt"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.UserId, arg.TokenHash, arg.ExpiresAt)
	return err
}
