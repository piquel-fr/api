// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email.sql

package repository

import (
	"context"
)

const addEmailAccount = `-- name: AddEmailAccount :one
INSERT INTO "mail_accounts" (
    "ownerId", "email", "name", "username", "password"
)
VALUES ($1, $2, $3, $4, $5) RETURNING "id"
`

type AddEmailAccountParams struct {
	OwnerId  int32  `json:"ownerId"`
	Email    string `json:"email"`
	Name     string `json:"name"`
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) AddEmailAccount(ctx context.Context, arg AddEmailAccountParams) (int32, error) {
	row := q.db.QueryRow(ctx, addEmailAccount,
		arg.OwnerId,
		arg.Email,
		arg.Name,
		arg.Username,
		arg.Password,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const countUserMailAccounts = `-- name: CountUserMailAccounts :one
SELECT COUNT(*) FROM "mail_accounts" WHERE "ownerId" = $1
`

func (q *Queries) CountUserMailAccounts(ctx context.Context, ownerid int32) (int64, error) {
	row := q.db.QueryRow(ctx, countUserMailAccounts, ownerid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMailAccountByEmail = `-- name: GetMailAccountByEmail :one
SELECT id, "ownerId", email, name, username, password FROM "mail_accounts" WHERE "email" = $1
`

func (q *Queries) GetMailAccountByEmail(ctx context.Context, email string) (MailAccount, error) {
	row := q.db.QueryRow(ctx, getMailAccountByEmail, email)
	var i MailAccount
	err := row.Scan(
		&i.ID,
		&i.OwnerId,
		&i.Email,
		&i.Name,
		&i.Username,
		&i.Password,
	)
	return i, err
}

const getMailAccountById = `-- name: GetMailAccountById :one
SELECT id, "ownerId", email, name, username, password FROM "mail_accounts" WHERE "id" = $1
`

func (q *Queries) GetMailAccountById(ctx context.Context, id int32) (MailAccount, error) {
	row := q.db.QueryRow(ctx, getMailAccountById, id)
	var i MailAccount
	err := row.Scan(
		&i.ID,
		&i.OwnerId,
		&i.Email,
		&i.Name,
		&i.Username,
		&i.Password,
	)
	return i, err
}

const listMailAccounts = `-- name: ListMailAccounts :many
SELECT id, "ownerId", email, name, username, password FROM "mail_accounts" LIMIT $1 OFFSET $2
`

type ListMailAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMailAccounts(ctx context.Context, arg ListMailAccountsParams) ([]MailAccount, error) {
	rows, err := q.db.Query(ctx, listMailAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MailAccount
	for rows.Next() {
		var i MailAccount
		if err := rows.Scan(
			&i.ID,
			&i.OwnerId,
			&i.Email,
			&i.Name,
			&i.Username,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMailAccounts = `-- name: ListUserMailAccounts :many
SELECT id, "ownerId", email, name, username, password FROM "mail_accounts" WHERE "ownerId" = $1 LIMIT $2 OFFSET $3
`

type ListUserMailAccountsParams struct {
	OwnerId int32 `json:"ownerId"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListUserMailAccounts(ctx context.Context, arg ListUserMailAccountsParams) ([]MailAccount, error) {
	rows, err := q.db.Query(ctx, listUserMailAccounts, arg.OwnerId, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MailAccount
	for rows.Next() {
		var i MailAccount
		if err := rows.Scan(
			&i.ID,
			&i.OwnerId,
			&i.Email,
			&i.Name,
			&i.Username,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMailAccount = `-- name: RemoveMailAccount :exec
DELETE FROM "mail_accounts" WHERE "id" = $1
`

func (q *Queries) RemoveMailAccount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, removeMailAccount, id)
	return err
}
