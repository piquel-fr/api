// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email.sql

package repository

import (
	"context"
)

const addEmailAccount = `-- name: AddEmailAccount :one
INSERT INTO "mail_accounts" (
    "ownerId", "email", "name", "username", "password"
)
VALUES ($1, $2, $3, $4, $5) RETURNING "id"
`

type AddEmailAccountParams struct {
	OwnerId  int32  `json:"ownerId"`
	Email    string `json:"email"`
	Name     string `json:"name"`
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) AddEmailAccount(ctx context.Context, arg AddEmailAccountParams) (int32, error) {
	row := q.db.QueryRow(ctx, addEmailAccount,
		arg.OwnerId,
		arg.Email,
		arg.Name,
		arg.Username,
		arg.Password,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addShare = `-- name: AddShare :exec
INSERT INTO "mail_share" (
    "userId", "account", "permission"
)
VALUES ($1, $2, $3)
`

type AddShareParams struct {
	UserId     int32  `json:"userId"`
	Account    int32  `json:"account"`
	Permission string `json:"permission"`
}

func (q *Queries) AddShare(ctx context.Context, arg AddShareParams) error {
	_, err := q.db.Exec(ctx, addShare, arg.UserId, arg.Account, arg.Permission)
	return err
}

const countUserMailAccounts = `-- name: CountUserMailAccounts :one
SELECT COUNT(DISTINCT "mail_accounts"."id")
FROM "mail_accounts"
LEFT JOIN "mail_share" ON "mail_accounts"."id" = "mail_share"."account"
WHERE "mail_accounts"."ownerId" = $1 OR "mail_share"."userId" = $1
`

func (q *Queries) CountUserMailAccounts(ctx context.Context, ownerid int32) (int64, error) {
	row := q.db.QueryRow(ctx, countUserMailAccounts, ownerid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMailAccountByEmail = `-- name: GetMailAccountByEmail :one
SELECT m.id, m."ownerId", m.email, m.name, m.username, m.password FROM "mail_accounts" m
LEFT JOIN "mail_share" s ON m."id" = s."account"
WHERE m."email" = $1 
LIMIT 1
`

func (q *Queries) GetMailAccountByEmail(ctx context.Context, email string) (MailAccount, error) {
	row := q.db.QueryRow(ctx, getMailAccountByEmail, email)
	var i MailAccount
	err := row.Scan(
		&i.ID,
		&i.OwnerId,
		&i.Email,
		&i.Name,
		&i.Username,
		&i.Password,
	)
	return i, err
}

const getMailAccountById = `-- name: GetMailAccountById :one
SELECT m.id, m."ownerId", m.email, m.name, m.username, m.password FROM "mail_accounts" m
LEFT JOIN "mail_share" s ON m."id" = s."account"
WHERE m."id" = $1 
LIMIT 1
`

func (q *Queries) GetMailAccountById(ctx context.Context, id int32) (MailAccount, error) {
	row := q.db.QueryRow(ctx, getMailAccountById, id)
	var i MailAccount
	err := row.Scan(
		&i.ID,
		&i.OwnerId,
		&i.Email,
		&i.Name,
		&i.Username,
		&i.Password,
	)
	return i, err
}

const listUserMailAccounts = `-- name: ListUserMailAccounts :many
SELECT DISTINCT mail_accounts.id, mail_accounts."ownerId", mail_accounts.email, mail_accounts.name, mail_accounts.username, mail_accounts.password FROM "mail_accounts"
LEFT JOIN "mail_share" ON "mail_accounts"."id" = "mail_share"."account"
WHERE "mail_accounts"."ownerId" = $1 OR "mail_share"."userId" = $1
ORDER BY "mail_accounts"."id"
`

func (q *Queries) ListUserMailAccounts(ctx context.Context, ownerid int32) ([]MailAccount, error) {
	rows, err := q.db.Query(ctx, listUserMailAccounts, ownerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MailAccount
	for rows.Next() {
		var i MailAccount
		if err := rows.Scan(
			&i.ID,
			&i.OwnerId,
			&i.Email,
			&i.Name,
			&i.Username,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMailAccount = `-- name: RemoveMailAccount :exec
DELETE FROM "mail_accounts" 
WHERE "id" = $1
`

func (q *Queries) RemoveMailAccount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, removeMailAccount, id)
	return err
}

const removeShare = `-- name: RemoveShare :exec
DELETE FROM "mail_share"
WHERE "userId" = $1 AND "account" = $2
`

type RemoveShareParams struct {
	UserId  int32 `json:"userId"`
	Account int32 `json:"account"`
}

func (q *Queries) RemoveShare(ctx context.Context, arg RemoveShareParams) error {
	_, err := q.db.Exec(ctx, removeShare, arg.UserId, arg.Account)
	return err
}
